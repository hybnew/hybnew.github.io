<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java Object的 wait &amp; notify &amp; notifyAll 方法探索 | If 十只橘猫九只胖</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。12345[TOC]#### 关于wait和notify/notifyAll的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Object的 wait & notify & notifyAll 方法探索">
<meta property="og:url" content="http://hybnew.github.io/2017/03/01/Java-Object的-wait-notify-notifyAll-方法探索/index.html">
<meta property="og:site_name" content="If 十只橘猫九只胖">
<meta property="og:description" content="wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。12345[TOC]#### 关于wait和notify/notifyAll的">
<meta property="og:updated_time" content="2017-03-01T10:19:24.130Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Object的 wait & notify & notifyAll 方法探索">
<meta name="twitter:description" content="wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。12345[TOC]#### 关于wait和notify/notifyAll的">
  
    <link rel="alternate" href="/atom.xml" title="If 十只橘猫九只胖" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">If 十只橘猫九只胖</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">还有一只特别胖</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hybnew.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java-Object的-wait-notify-notifyAll-方法探索" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/Java-Object的-wait-notify-notifyAll-方法探索/" class="article-date">
  <time datetime="2017-03-01T03:25:33.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java Object的 wait &amp; notify &amp; notifyAll 方法探索
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  <figure class="highlight plain"><figcaption><span>的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[TOC]</div><div class="line"></div><div class="line">#### 关于wait和notify/notifyAll的使用</div><div class="line">举个栗子，关于消费者和生产者模型，会遇到队列（共享变量）为空即没有产品和队列已满的情况；如果是不使用ArrayBlockingQueue等阻塞队列，那么就需要自己对线程间的通信，或者称之为同步。说干就干，写个demo还是不费时间的。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.UUID;</p>
<p>/**</p>
<ul>
<li><p>Created by Rick on 2017/3/1.<br>*/<br>public class UncatchExceptionHandler {</p>
<p> private static volatile List<string> queue = new ArrayList&lt;&gt;(10);</string></p>
<p> public static void main(String[] args) {</p>
<pre><code>class R implements Runnable {
    @Override
    public void run() {
        for (; ; ) {

            synchronized (queue) {
                while (queue.size() == 0) {// must == 0
                    try {
                        //WAIT here util other thread notify
                        queue.wait();// same with wait(0)
</code></pre></li>
</ul>
<pre><code>                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName() + &quot;消费数据&quot; + queue.remove(queue.size() - 1) + &quot;,size=&quot; + queue.size());
                queue.notify();
                //queue.notifyAll();
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

Thread consumer1 = new Thread(new R());
Thread consumer2 = new Thread(new R());

Thread producer = new Thread(new Runnable() {
    @Override
    public void run() {

        for (; ; ) {

            synchronized (queue) {
                while (queue.size() == 10) {
                    try {
                        queue.wait(0);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                UUID rand = UUID.randomUUID();
                System.out.println(&quot;生产数据 :&quot; + rand.toString() + &quot;,size=&quot; + queue.size());

                queue.add(rand.toString());
                queue.notify();
</code></pre><p>//                        queue.notifyAll();<br>                        try {<br>                            Thread.sleep(1000);<br>                        } catch (InterruptedException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }<br>            }<br>        });</p>
<pre><code>    consumer1.start();
    consumer2.start();
    producer.start();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### javadoc reference</div><div class="line">&gt; &lt;pre&gt;Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.</div><div class="line">The current thread must own this object&apos;s monitor.</div><div class="line">This method causes the current thread (call it T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</div><div class="line">Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened.</div><div class="line">Some other thread invokes the notifyAll method for this object.</div><div class="line">Some other thread interrupts thread T.</div><div class="line">The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</div><div class="line">The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.</div><div class="line">A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:</div><div class="line">           synchronized (obj) &#123;</div><div class="line">               while (&lt;condition does not hold&gt;)</div><div class="line">                   obj.wait(timeout);</div><div class="line">               ... // Perform action appropriate to condition</div><div class="line">           &#125;</div><div class="line">(For more information on this topic, see Section 3.2.3 in Doug Lea&apos;s &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley, 2000), or Item 50 in Joshua Bloch&apos;s &quot;Effective Java Programming Language Guide&quot; (Addison-Wesley, 2001).</div><div class="line">If the current thread is interrupted by any thread before or while it is waiting, then an InterruptedException is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</div><div class="line">Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.</div><div class="line">This method should only be called by a thread that is the owner of this object&apos;s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.&lt;/pre&gt;</div><div class="line"></div><div class="line">其中</div></pre></td></tr></table></figure></p>
<p>synchronized (obj) {<br>   while (<condition does="" not="" hold="">)<br>       obj.wait(timeout);<br>   … // Perform action appropriate to condition<br>}<br>```<br>这句话尤为重要。</condition></p>
<h4 id="wait方法的loop纠结"><a href="#wait方法的loop纠结" class="headerlink" title="wait方法的loop纠结"></a>wait方法的loop纠结</h4><h4 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a>notify和notifyAll的区别</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hybnew.github.io/2017/03/01/Java-Object的-wait-notify-notifyAll-方法探索/" data-id="cizqlezlx0003vsgs2arw5o4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/01/用Fork-And-Join框架计算Fibonacci数列/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          用Fork And Join框架计算Fibonacci数列
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/01/本博客的入坑纪实-Hexo博客平台/">本博客的入坑纪实-Hexo博客平台</a>
          </li>
        
          <li>
            <a href="/2017/03/01/java-线程的运行时异常处理-UncaughtExceptionHandler/">java 线程的运行时异常处理-UncaughtExceptionHandler</a>
          </li>
        
          <li>
            <a href="/2017/03/01/HashMap-源码分析/">HashMap 源码分析</a>
          </li>
        
          <li>
            <a href="/2017/03/01/CocurrentHashMap-源码试解读/">CocurrentHashMap 源码试解读</a>
          </li>
        
          <li>
            <a href="/2017/03/01/AbstractQueuedSynchronizer-AQS-源码试解读/">AbstractQueuedSynchronizer (AQS) 源码试解读</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Rick Ho<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>