<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JUC 的原子操作类AtomicReference & 与volatile的区别]]></title>
      <url>%2F2017%2F03%2F02%2FJUC-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReference-%E4%B8%8Evolatile%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[分离任务与多线程的封装]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%88%86%E7%A6%BB%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例模式的几种套路]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[本博客的入坑纪实-Hexo博客平台]]></title>
      <url>%2F2017%2F03%2F01%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%A5%E5%9D%91%E7%BA%AA%E5%AE%9E-Hexo%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 线程的运行时异常处理-UncaughtExceptionHandler]]></title>
      <url>%2F2017%2F03%2F01%2Fjava-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-UncaughtExceptionHandler%2F</url>
      <content type="text"><![CDATA[Java 线程(Runnable)的异常处理, 以下的阐述均基于Runnable的线程实现 首先，有个问题，如果Java子线程发生异常会怎么样？实际上会导致该线程直接终止。当年自己写了个线程模型大概是这样的： 123Spring容器启动 (1) -&gt; 主线程中启动一个子线程T，在while循环中去接收socket请求 (2) -&gt; 收到一个请求，submit一个线程 (3) 当时我一只担心步骤2的线程T会因为什么而挂掉，然后大家没办法上传文件。而当时完全不知道UncaughtExceptionHandler的存在，多希望有一丁点指导啊。 那么如何处理可能出现的异常而不至于线程直接挂掉呢？第一，把整个run中的异常在内部捕获掉第二，直接在线程中setUncaughtExceptionHandler,将异常处理与run分开。 其实，有的同学可能疑惑，为什么不能直接把整个线程用try-catch包裹起来。因为这本来就没有什么用，譬如： 1234567// 普通线程即使使用try...catch也无法捕获到抛出的异常 try &#123; Thread t = new Thread(); t.start(); &#125; catch (Exception e) &#123; System.out.println(&quot;catch RunTimeException &quot;); // 不起作用 &#125; 假设t是从线程x中 new 出来的，那么x称为t的父线程。而线程与线程间的运行本是异步的（当然如果不使用线程间通信机制的情况下），有可能x在t还没结束时先结束，这是有可能的，如果x不是主线程的话。 所以，try-catch在异步的线程中捕获是没有意义的。正确的方法是：123456789new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123;//wrap all code Integer.parseInt(&quot;sfasf&quot;); System.out.println(0); &#125;catch(...)&#123;&#125; &#125;&#125;).start(); 或者使用UncaughtExceptionHandler 捕获线程运行体的运行时异常，使用也很简单：123456789101112/** * 继承UncaughtExceptionHandler 接口 */class ErrHandler implements UncaughtExceptionHandler&#123; public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(&quot;This is:&quot; + t.getName() + &quot;,Message:&quot; + e.getMessage()); e.printStackTrace(); &#125;&#125; 在线程中使用：123456789101112new Thread(new Runnable() &#123; @Override public void run() &#123; Thread.currentThread().setUncaughtExceptionHandler(ErrHandler); //Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; &#123; // System.out.println(&quot;current thread is &quot; + t.getName() + &quot; &quot; + e.getMessage()); //&#125;); Integer.parseInt(&quot;sfasf&quot;); System.out.println(0); &#125;&#125;).start(); 如果没有捕获异常，不会输出0，而有了handler则不影响下面的执行，会正常输出了。或者是：12Thread a = new Thread();a.setUncaughtExceptionHandler(ErrHandler); 正如上面所写，在java 8中还可以用lamda表达式简化语法，用匿名handler代替。不过使用a.setUEH(handler)这种方式是策略模式的体现，更容易在需要的时候随时替换handler的实现，正如sort函数的Comparator参数一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashMap 源码分析]]></title>
      <url>%2F2017%2F03%2F01%2FHashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocurrentHashMap 源码试解读]]></title>
      <url>%2F2017%2F03%2F01%2FCocurrentHashMap-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer (AQS) 源码试解读]]></title>
      <url>%2F2017%2F03%2F01%2FAbstractQueuedSynchronizer-AQS-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Fork And Join框架计算Fibonacci数列]]></title>
      <url>%2F2017%2F03%2F01%2F%E7%94%A8Fork-And-Join%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97Fibonacci%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[Fork And Join 的并发框架对与大型任务的分解计算是十分方便的。主要是将任务分割（fork）最后再合并（join）得到结果。实际上使用了分治的思想。其中涉及到任务窃取算法等。 以下是一个计算Fibonacci数列的Demo,使用BigInteger是为了避免溢出，但是计算效率大大降低，可以用Long类型代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.tw;import java.math.BigInteger;import java.util.HashMap;import java.util.Map;import java.util.concurrent.RecursiveTask;/** * Created by Rick on 2017/2/27. */public class ForkAndJoinTest extends RecursiveTask&lt;BigInteger&gt; &#123; private int num; private Map&lt;BigInteger, BigInteger&gt; intermediateResult; public ForkAndJoinTest(int num, Map&lt;BigInteger, BigInteger&gt; map) &#123; this.num = num; intermediateResult = map; &#125; @Override protected BigInteger compute() &#123; if (num == 2) return BigInteger.valueOf(1); if (num == 1) return BigInteger.valueOf(1); if (num == 0) return BigInteger.valueOf(0); BigInteger lr, rr; int i = num - 1; int i1 = num - 2; lr = getBigInteger(i); rr = getBigInteger(i1); return lr.add(rr); &#125; /** * 使用map缓存计算结果 */ private BigInteger getBigInteger(int i) &#123; BigInteger lr; if (null != intermediateResult.get(i)) lr = intermediateResult.get(i);//cacha number else &#123; ForkAndJoinTest join1 = new ForkAndJoinTest(i, intermediateResult); join1.fork(); lr = join1.join(); intermediateResult.put(BigInteger.valueOf(i), lr); &#125; return lr; &#125; public ForkAndJoinTest() &#123; &#125; public static void main(String[] args) &#123;// 1,1,2,3,5,8,13,21 Map&lt;BigInteger, BigInteger&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 90; i++) &#123; ForkAndJoinTest faj = new ForkAndJoinTest(i, map); faj.fork(); BigInteger join = faj.join(); System.out.println(&quot;#&quot; + i + &quot; &quot; + join); &#125; &#125;&#125; 举一反三，例如计算1+2+…+n就可以使用这种多线程模型，假设1+2比较耗时的话。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Object的 wait & notify & notifyAll 方法探索]]></title>
      <url>%2F2017%2F03%2F01%2FJava-Object%E7%9A%84-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java Object 的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。 关于wait和notify/notifyAll的使用举个栗子，关于消费者和生产者模型，会遇到队列（共享变量）为空即没有产品和队列已满的情况；如果是不使用ArrayBlockingQueue等阻塞队列，那么就需要自己对线程间的通信，或者称之为同步。说干就干，写个demo还是不费时间的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * Created by Rick on 2017/3/1. */public class UncatchExceptionHandler &#123; private static volatile List&lt;String&gt; queue = new ArrayList&lt;&gt;(10); public static void main(String[] args) &#123; class R implements Runnable &#123; @Override public void run() &#123; for (; ; ) &#123; synchronized (queue) &#123; while (queue.size() == 0) &#123;// must == 0 try &#123; //WAIT here util other thread notify queue.wait();// same with wait(0) &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "消费数据" + queue.remove(queue.size() - 1) + ",size=" + queue.size()); queue.notify(); //queue.notifyAll(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; Thread consumer1 = new Thread(new R()); Thread consumer2 = new Thread(new R()); Thread producer = new Thread(new Runnable() &#123; @Override public void run() &#123; for (; ; ) &#123; synchronized (queue) &#123; while (queue.size() == 10) &#123; try &#123; queue.wait(0); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; UUID rand = UUID.randomUUID(); System.out.println("生产数据 :" + rand.toString() + ",size=" + queue.size()); queue.add(rand.toString()); queue.notify();// queue.notifyAll(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;); consumer1.start(); consumer2.start(); producer.start(); &#125;&#125; javadoc reference 123456789101112131415161718&gt; Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.&gt; The current thread must own this object&apos;s monitor.&gt; This method causes the current thread (call it T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:&gt; Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened.&gt; Some other thread invokes the notifyAll method for this object.&gt; Some other thread interrupts thread T.&gt; The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.&gt; The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.&gt; A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:&gt; synchronized (obj) &#123;&gt; while ( &lt;condition does=&quot;&quot; not=&quot;&quot; hold=&quot;&quot;&gt;)&gt; obj.wait(timeout);&gt; ... // Perform action appropriate to condition&gt; &#125;&gt; (For more information on this topic, see Section 3.2.3 in Doug Lea&apos;s &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley, 2000), or Item 50 in Joshua Bloch&apos;s &quot;Effective Java Programming Language Guide&quot; (Addison-Wesley, 2001).&gt; If the current thread is interrupted by any thread before or while it is waiting, then an InterruptedException is thrown. This exception is not thrown until the lock status of this object has been restored as described above.&gt; Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.&gt; This method should only be called by a thread that is the owner of this object&apos;s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.&lt;/condition&gt; 其中 12345synchronized (obj) &#123; while (&lt;condition does not hold&gt;) obj.wait(timeout); ... // Perform action appropriate to condition&#125; 这句话尤为重要。 wait方法的loop纠结notify和notifyAll的区别本文重点： 你可以使用wait和notify函数来实现线程间通信。你可以用它们来实现多线程（&gt;3）之间的通信。 永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。 永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。 永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。 基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。 如何在 Java 中正确使用 wait, notify 和 notifyAll &#8211; 以生产者消费者模型为例这是关于Java里如何使用wait, notify和notifyAll的所有重点啦。你应该只在你知道自己要做什么的情况下使用这些函数，不然Java里还有很多其它的用来解决同步问题的方 案。例如，如果你想使用生产者消费者模型的话，你也可以使用BlockingQueue，它会帮你处理所有的线程安全问题和流程控制。如果你想要某一个线 程等待另一个线程做出反馈再继续运行，你也可以使用CycliBarrier或者CountDownLatch。如果你只是想保护某一个资源的话，你也可 以使用Semaphore。]]></content>
    </entry>

    
  
  
</search>
