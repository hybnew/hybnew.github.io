<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>If 十只橘猫九只胖</title>
  <subtitle>Then 还有一只特别胖</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="https://git.coding.net/yb007/yb007.coding.me.git/"/>
  <updated>2017-03-08T04:45:33.486Z</updated>
  <id>https://git.coding.net/yb007/yb007.coding.me.git/</id>
  
  <author>
    <name>Rick Ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊并发-Java中的Copy-On-Write容器(转载自并发网)</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/08/%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91-Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8-%E8%BD%AC%E8%BD%BD%E8%87%AA%E5%B9%B6%E5%8F%91%E7%BD%91/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/08/聊聊并发-Java中的Copy-On-Write容器-转载自并发网/</id>
    <published>2017-03-08T03:35:29.000Z</published>
    <updated>2017-03-08T04:45:33.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聊聊并发-Java中的Copy-On-Write容器-转载自并发网"><a href="#聊聊并发-Java中的Copy-On-Write容器-转载自并发网" class="headerlink" title="聊聊并发-Java中的Copy-On-Write容器(转载自并发网)"></a>聊聊并发-Java中的Copy-On-Write容器(<a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">转载自并发网</a>)</h2><blockquote>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
</blockquote>
<a id="more"></a>
<h4 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h4><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h4 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h4><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Object[] elements = getArray();</div><div class="line">       <span class="keyword">int</span> len = elements.length;</div><div class="line">        <span class="comment">// 复制出新数组</span></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        <span class="comment">// 把新元素添加到新数组里</span></div><div class="line">        newElements[len] = e;</div><div class="line">        <span class="comment">// 把原数组引用指向新数组</span></div><div class="line">       setArray(newElements);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;K, V&gt; internalMap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        internalMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> internalMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; newData)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h4 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h4><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.ifeve.book;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.ifeve.book.forkjoin.CopyOnWriteMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 黑名单服务</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> fangtengfei</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = <span class="keyword">new</span> CopyOnWriteMap&lt;String, Boolean&gt;(</div><div class="line">            <span class="number">1000</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> blackListMap.get(id) == <span class="keyword">null</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        blackListMap.put(id, Boolean.TRUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 批量添加黑名单</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ids</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(Map&lt;String,Boolean&gt; ids)</span> </span>&#123;</div><div class="line">        blackListMap.putAll(ids);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
</li>
</ol>
<h4 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h4><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;聊聊并发-Java中的Copy-On-Write容器-转载自并发网&quot;&gt;&lt;a href=&quot;#聊聊并发-Java中的Copy-On-Write容器-转载自并发网&quot; class=&quot;headerlink&quot; title=&quot;聊聊并发-Java中的Copy-On-Write容器(转载自并发网)&quot;&gt;&lt;/a&gt;聊聊并发-Java中的Copy-On-Write容器(&lt;a href=&quot;http://ifeve.com/java-copy-on-write/&quot;&gt;转载自并发网&lt;/a&gt;)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JUC 的原子操作类AtomicReference &amp; 与volatile的区别</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/02/JUC-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReference-%E4%B8%8Evolatile%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/02/JUC-的原子操作类AtomicReference-与volatile的区别/</id>
    <published>2017-03-02T04:52:19.000Z</published>
    <updated>2017-03-08T09:57:29.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code> 常常与 <code>synchronized</code> 作比较，简单的说，synchronized 具有<code>互斥性</code> &amp; <code>可见性</code>，而volatile 仅有<code>可见性</code>;可见性保证了线程间更新了之后其他线程可以马上发现更新的值。但是，volatile并不能保证多线程下变量操作的原子性。所以类似i++或者long类型的操作等，如果在volatile修饰的field上面，依然会产生脏数据。<br>要保证原子性，可以使用volatile + CAS的实现方式。<br>以下出自方腾飞<a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="external">《聊聊并发（一）深入分析Volatile的实现原理》</a></p>
<blockquote>
<p>使用volatile变量修饰符如果使用恰当的话，它比synchronized的<strong>使用和执行成本会更低</strong>，因为它不会引起线程上下文的<strong>切换和调度</strong>。</p>
</blockquote>
<p>而这些都是Java内存模型保证的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h3&gt;&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 常常与 &lt;code&gt;synchronized&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分离任务与多线程的封装</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/%E5%88%86%E7%A6%BB%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/分离任务与多线程的封装/</id>
    <published>2017-03-01T12:44:57.000Z</published>
    <updated>2017-03-01T12:44:57.969Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式的几种套路</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/单例模式的几种套路/</id>
    <published>2017-03-01T12:44:14.000Z</published>
    <updated>2017-03-01T12:44:14.839Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>本博客的入坑纪实-Hexo博客平台</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%A5%E5%9D%91%E7%BA%AA%E5%AE%9E-Hexo%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/本博客的入坑纪实-Hexo博客平台/</id>
    <published>2017-03-01T05:47:39.000Z</published>
    <updated>2017-03-01T05:47:39.280Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 线程的运行时异常处理-UncaughtExceptionHandler</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-UncaughtExceptionHandler/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/java-线程的运行时异常处理-UncaughtExceptionHandler/</id>
    <published>2017-03-01T05:41:33.000Z</published>
    <updated>2017-03-03T06:34:24.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java 线程(Runnable)的异常处理, 以下的阐述均基于Runnable的线程实现</strong></p>
<p>首先，有个问题，如果Java子线程发生异常会怎么样？实际上会导致该线程直接终止。当年自己写了个线程模型大概是这样的：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Spring容器启动 (1)</div><div class="line">  -&gt; 主线程中启动一个子线程T，在while循环中去接收socket请求 (2)</div><div class="line">    -&gt; 收到一个请求，submit一个线程 (3)</div></pre></td></tr></table></figure>
<p>当时我一只担心步骤2的线程T会因为什么而挂掉，然后大家没办法上传文件。而当时完全不知道UncaughtExceptionHandler的存在，多希望有一丁点指导啊。</p>
<p>那么如何处理可能出现的异常而不至于线程直接挂掉呢？<br>第一，把整个run中的异常在内部捕获掉<br>第二，直接在线程中setUncaughtExceptionHandler,将异常处理与run分开。</p>
<p>其实，有的同学可能疑惑，为什么不能直接把整个线程用try-catch包裹起来。因为这本来就没有什么用，譬如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 普通线程即使使用try...catch也无法捕获到抛出的异常</div><div class="line">       try &#123;</div><div class="line">           Thread t = new Thread();</div><div class="line">           t.start();</div><div class="line">       &#125; catch (Exception e) &#123;</div><div class="line">           System.out.println(&quot;catch RunTimeException &quot;); // 不起作用</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>假设t是从线程x中 <code>new</code> 出来的，那么x称为t的父线程。而线程与线程间的运行本是异步的（当然如果不使用线程间通信机制的情况下），有可能x在t还没结束时先结束，这是有可能的，如果x不是主线程的话。 所以，try-catch在异步的线程中捕获是没有意义的。<br>正确的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try&#123;//wrap all code</div><div class="line">            Integer.parseInt(&quot;sfasf&quot;);</div><div class="line">            System.out.println(0);</div><div class="line">        &#125;catch(...)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>或者使用UncaughtExceptionHandler 捕获线程运行体的运行时异常，使用也很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 继承UncaughtExceptionHandler 接口</div><div class="line"> */</div><div class="line">class ErrHandler implements UncaughtExceptionHandler</div><div class="line">&#123;</div><div class="line">    public void uncaughtException(Thread t, Throwable e)</div><div class="line">    &#123;</div><div class="line">        System.out.println(&quot;This is:&quot; + t.getName() + &quot;,Message:&quot; + e.getMessage());</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在线程中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">        Thread.currentThread().setUncaughtExceptionHandler(ErrHandler);</div><div class="line">        //Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; &#123;</div><div class="line">        //    System.out.println(&quot;current thread is &quot; + t.getName() + &quot; &quot; + e.getMessage());</div><div class="line">        //&#125;);</div><div class="line">        Integer.parseInt(&quot;sfasf&quot;);</div><div class="line">        System.out.println(0);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>如果没有捕获异常，不会输出0，而有了handler则不影响下面的执行，会正常输出了。<br>或者是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread a = new Thread();</div><div class="line">a.setUncaughtExceptionHandler(ErrHandler);</div></pre></td></tr></table></figure></p>
<p>正如上面所写，在java 8中还可以用lamda表达式简化语法，用匿名handler代替。不过使用<code>a.setUEH(handler)</code>这种方式是策略模式的体现，更容易在需要的时候随时替换handler的实现，正如sort函数的Comparator参数一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java 线程(Runnable)的异常处理, 以下的阐述均基于Runnable的线程实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，有个问题，如果Java子线程发生异常会怎么样？实际上会导致该线程直接终止。当年自己写了个线程模型大概是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://git.coding.net/yb007/yb007.coding.me.git/categories/Java/"/>
    
    
      <category term="Java" scheme="https://git.coding.net/yb007/yb007.coding.me.git/tags/Java/"/>
    
      <category term="线程" scheme="https://git.coding.net/yb007/yb007.coding.me.git/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="异常" scheme="https://git.coding.net/yb007/yb007.coding.me.git/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="UncaughtExceptionHandler" scheme="https://git.coding.net/yb007/yb007.coding.me.git/tags/UncaughtExceptionHandler/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码分析</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/HashMap-源码分析/</id>
    <published>2017-03-01T04:11:29.000Z</published>
    <updated>2017-03-01T04:11:29.901Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap 源码试解读</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/CocurrentHashMap-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/CocurrentHashMap-源码试解读/</id>
    <published>2017-03-01T04:11:11.000Z</published>
    <updated>2017-03-01T04:11:11.231Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer (AQS) 源码试解读</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/AbstractQueuedSynchronizer-AQS-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/AbstractQueuedSynchronizer-AQS-源码试解读/</id>
    <published>2017-03-01T04:10:51.000Z</published>
    <updated>2017-03-01T04:10:51.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Fork And Join框架计算Fibonacci数列</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/%E7%94%A8Fork-And-Join%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97Fibonacci%E6%95%B0%E5%88%97/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/用Fork-And-Join框架计算Fibonacci数列/</id>
    <published>2017-03-01T04:08:50.000Z</published>
    <updated>2017-03-03T06:16:57.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Fork And Join 的并发框架对与大型任务的分解计算是十分方便的。主要是将任务分割（fork）最后再合并（join）得到结果。<br>实际上使用了<code>分治</code>的思想。其中涉及到任务窃取算法等。</p>
</blockquote>
<p>以下是一个计算Fibonacci数列的Demo,使用BigInteger是为了避免溢出，但是计算效率大大降低，可以用Long类型代替。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package com.tw;</div><div class="line"></div><div class="line">import java.math.BigInteger;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.RecursiveTask;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Rick on 2017/2/27.</div><div class="line"> */</div><div class="line">public class ForkAndJoinTest extends RecursiveTask&lt;BigInteger&gt; &#123;</div><div class="line">    private int num;</div><div class="line">    private Map&lt;BigInteger, BigInteger&gt; intermediateResult;</div><div class="line"></div><div class="line">    public ForkAndJoinTest(int num, Map&lt;BigInteger, BigInteger&gt; map) &#123;</div><div class="line">        this.num = num;</div><div class="line">        intermediateResult = map;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected BigInteger compute() &#123;</div><div class="line">        if (num == 2)</div><div class="line">            return BigInteger.valueOf(1);</div><div class="line">        if (num == 1)</div><div class="line">            return BigInteger.valueOf(1);</div><div class="line">        if (num == 0)</div><div class="line">            return BigInteger.valueOf(0);</div><div class="line"></div><div class="line">        BigInteger lr, rr;</div><div class="line">        int i = num - 1;</div><div class="line">        int i1 = num - 2;</div><div class="line">        lr = getBigInteger(i);</div><div class="line">        rr = getBigInteger(i1);</div><div class="line"></div><div class="line">        return lr.add(rr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 使用map缓存计算结果</div><div class="line">    */</div><div class="line">    private BigInteger getBigInteger(int i) &#123;</div><div class="line">        BigInteger lr;</div><div class="line">        if (null != intermediateResult.get(i))</div><div class="line">            lr = intermediateResult.get(i);//cacha number</div><div class="line">        else &#123;</div><div class="line">            ForkAndJoinTest join1 = new ForkAndJoinTest(i, intermediateResult);</div><div class="line">            join1.fork();</div><div class="line">            lr = join1.join();</div><div class="line">            intermediateResult.put(BigInteger.valueOf(i), lr);</div><div class="line">        &#125;</div><div class="line">        return lr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ForkAndJoinTest() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">//        1,1,2,3,5,8,13,21</div><div class="line">        Map&lt;BigInteger, BigInteger&gt; map = new HashMap&lt;&gt;();</div><div class="line">        for (int i = 0; i &lt; 90; i++) &#123;</div><div class="line"></div><div class="line">            ForkAndJoinTest faj = new ForkAndJoinTest(i, map);</div><div class="line">            faj.fork();</div><div class="line">            BigInteger join = faj.join();</div><div class="line">            System.out.println(&quot;#&quot; + i + &quot; &quot; + join);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举一反三，例如计算1+2+…+n就可以使用这种多线程模型，假设1+2比较耗时的话。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fork And Join 的并发框架对与大型任务的分解计算是十分方便的。主要是将任务分割（fork）最后再合并（join）得到结果。&lt;br&gt;实际上使用了&lt;code&gt;分治&lt;/code&gt;的思想。其中涉及到任务窃取算法等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是一个计算Fibonacci数列的Demo,使用BigInteger是为了避免溢出，但是计算效率大大降低，可以用Long类型代替。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Object的 wait &amp; notify &amp; notifyAll 方法探索</title>
    <link href="https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/Java-Object%E7%9A%84-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/"/>
    <id>https://git.coding.net/yb007/yb007.coding.me.git/2017/03/01/Java-Object的-wait-notify-notifyAll-方法探索/</id>
    <published>2017-03-01T03:25:33.000Z</published>
    <updated>2017-03-08T09:41:11.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java <code>Object</code> 的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。</p>
</blockquote>
<a id="more"></a>
<h1 id="关于wait和notify-notifyAll的使用"><a href="#关于wait和notify-notifyAll的使用" class="headerlink" title="关于wait和notify/notifyAll的使用"></a>关于wait和notify/notifyAll的使用</h1><p>举个栗子，关于消费者和生产者模型，会遇到队列（共享变量）为空即没有产品和队列已满的情况；如果是不使用ArrayBlockingQueue等阻塞队列，那么就需要自己对线程间的通信，或者称之为同步。说干就干，写个demo还是不费时间的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.UUID;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Rick on 2017/3/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UncatchExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (; ; ) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">                        <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;<span class="comment">// must == 0</span></div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                <span class="comment">//WAIT here util other thread notify</span></div><div class="line">                                queue.wait();<span class="comment">// same with wait(0)</span></div><div class="line"></div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"消费数据"</span> + queue.remove(queue.size() - <span class="number">1</span>) + <span class="string">",size="</span> + queue.size());</div><div class="line">                        queue.notify();</div><div class="line">                        <span class="comment">//queue.notifyAll();</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            Thread.sleep(<span class="number">1000</span>);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread consumer1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> R());</div><div class="line">        Thread consumer2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> R());</div><div class="line"></div><div class="line">        Thread producer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (; ; ) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">                        <span class="keyword">while</span> (queue.size() == <span class="number">10</span>) &#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                queue.wait(<span class="number">0</span>);</div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        UUID rand = UUID.randomUUID();</div><div class="line">                        System.out.println(<span class="string">"生产数据 :"</span> + rand.toString() + <span class="string">",size="</span> + queue.size());</div><div class="line"></div><div class="line">                        queue.add(rand.toString());</div><div class="line">                        queue.notify();</div><div class="line"><span class="comment">//                        queue.notifyAll();</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            Thread.sleep(<span class="number">1000</span>);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        consumer1.start();</div><div class="line">        consumer2.start();</div><div class="line">        producer.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="javadoc-reference"><a href="#javadoc-reference" class="headerlink" title="javadoc reference"></a>javadoc reference</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.</div><div class="line">&gt; The current thread must own this object&apos;s monitor.</div><div class="line">&gt; This method causes the current thread (call it T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</div><div class="line">&gt; Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened.</div><div class="line">&gt; Some other thread invokes the notifyAll method for this object.</div><div class="line">&gt; Some other thread interrupts thread T.</div><div class="line">&gt; The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</div><div class="line">&gt; The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.</div><div class="line">&gt; A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:</div><div class="line">&gt;            synchronized (obj) &#123;</div><div class="line">&gt;                while ( &lt;condition does=&quot;&quot; not=&quot;&quot; hold=&quot;&quot;&gt;)</div><div class="line">&gt;                    obj.wait(timeout);</div><div class="line">&gt;                ... // Perform action appropriate to condition</div><div class="line">&gt;            &#125;</div><div class="line">&gt; (For more information on this topic, see Section 3.2.3 in Doug Lea&apos;s &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley, 2000), or Item 50 in Joshua Bloch&apos;s &quot;Effective Java Programming Language Guide&quot; (Addison-Wesley, 2001).</div><div class="line">&gt; If the current thread is interrupted by any thread before or while it is waiting, then an InterruptedException is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</div><div class="line">&gt; Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.</div><div class="line">&gt; This method should only be called by a thread that is the owner of this object&apos;s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.&lt;/condition&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">   <span class="keyword">while</span> (&lt;condition does not hold&gt;)</div><div class="line">       obj.wait(timeout);</div><div class="line">   ... <span class="comment">// Perform action appropriate to condition</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这句话尤为重要。</p>
<h1 id="wait方法的loop纠结"><a href="#wait方法的loop纠结" class="headerlink" title="wait方法的loop纠结"></a>wait方法的loop纠结</h1><h1 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a>notify和notifyAll的区别</h1><p>本文重点：</p>
<ol>
<li>你可以使用wait和notify函数来实现线程间通信。你可以用它们来实现多线程（&gt;3）之间的通信。</li>
<li>永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。</li>
<li>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。</li>
<li>永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。</li>
<li>基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。</li>
</ol>
<p><img src="../../style.jpg" alt="code module"></p>
<p>如何在 Java 中正确使用 wait, notify 和 notifyAll &#8211; 以生产者消费者模型为例<br>这是关于Java里如何使用wait, notify和notifyAll的所有重点啦。你应该只在你知道自己要做什么的情况下使用这些函数，不然Java里还有很多其它的用来解决同步问题的方 案。例如，如果你想使用生产者消费者模型的话，你也可以使用BlockingQueue，它会帮你处理所有的线程安全问题和流程控制。如果你想要某一个线 程等待另一个线程做出反馈再继续运行，你也可以使用CycliBarrier或者CountDownLatch。如果你只是想保护某一个资源的话，你也可 以使用Semaphore。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java &lt;code&gt;Object&lt;/code&gt; 的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
