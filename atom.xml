<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>If 十只橘猫九只胖</title>
  <subtitle>还有一只特别胖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hybnew.github.io/"/>
  <updated>2017-03-01T12:44:57.969Z</updated>
  <id>http://hybnew.github.io/</id>
  
  <author>
    <name>Rick Ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分离任务与多线程的封装</title>
    <link href="http://hybnew.github.io/2017/03/01/%E5%88%86%E7%A6%BB%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://hybnew.github.io/2017/03/01/分离任务与多线程的封装/</id>
    <published>2017-03-01T12:44:57.000Z</published>
    <updated>2017-03-01T12:44:57.969Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式的几种套路</title>
    <link href="http://hybnew.github.io/2017/03/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"/>
    <id>http://hybnew.github.io/2017/03/01/单例模式的几种套路/</id>
    <published>2017-03-01T12:44:14.000Z</published>
    <updated>2017-03-01T12:44:14.839Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>本博客的入坑纪实-Hexo博客平台</title>
    <link href="http://hybnew.github.io/2017/03/01/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%A5%E5%9D%91%E7%BA%AA%E5%AE%9E-Hexo%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>http://hybnew.github.io/2017/03/01/本博客的入坑纪实-Hexo博客平台/</id>
    <published>2017-03-01T05:47:39.000Z</published>
    <updated>2017-03-01T05:47:39.280Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 线程的运行时异常处理-UncaughtExceptionHandler</title>
    <link href="http://hybnew.github.io/2017/03/01/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-UncaughtExceptionHandler/"/>
    <id>http://hybnew.github.io/2017/03/01/java-线程的运行时异常处理-UncaughtExceptionHandler/</id>
    <published>2017-03-01T05:41:33.000Z</published>
    <updated>2017-03-01T08:48:37.740Z</updated>
    
    <content type="html"><![CDATA[<p>首先，有个问题，如果Java子线程发生异常会怎么样？实际上会导致该线程直接终止。<br>当年自己写了个线程模型大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Spring容器启动 (1)</div><div class="line">  -&gt; 主线程中启动一个子线程T，在while循环中去接收socket请求 (2)</div><div class="line">    -&gt; 收到一个请求，submit一个线程 (3)</div></pre></td></tr></table></figure>
<p>当时我一只担心步骤2的线程T会因为什么而挂掉，然后大家没办法上传文件。而当时完全不知道UncaughtExceptionHandler的存在，多希望有一丁点指导啊。</p>
<p>那么如何处理可能出现的异常而不至于线程直接挂掉呢？<br>第一，把整个run中的异常在内部捕获掉<br>第二，直接在线程中setUncaughtExceptionHandler,将异常处理与run分开。</p>
<p>其实，有的同学可能疑惑，为什么不能直接把整个线程用try-catch包裹起来。因为这本来就没有什么用，譬如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 普通线程即使使用try...catch也无法捕获到抛出的异常</div><div class="line">       try &#123;</div><div class="line">           Thread t = new Thread();</div><div class="line">           t.start();</div><div class="line">       &#125; catch (Exception e) &#123;</div><div class="line">           System.out.println(&quot;catch RunTimeException &quot;); // 不起作用</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>假设t是从线程x中 <code>new</code> 出来的，那么x称为t的父线程。而线程与线程间的运行本是异步的（当然如果不使用线程间通信机制的情况下），有可能x在t还没结束时先结束，这是有可能的，如果x不是主线程的话。 所以，try-catch在异步的线程中捕获是没有意义的。<br>正确的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try&#123;//wrap all code</div><div class="line">            Integer.parseInt(&quot;sfasf&quot;);</div><div class="line">            System.out.println(0);</div><div class="line">        &#125;catch(...)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>或者使用UncaughtExceptionHandler 捕获线程运行体的运行时异常，使用也很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 继承UncaughtExceptionHandler 接口</div><div class="line"> */</div><div class="line">class ErrHandler implements UncaughtExceptionHandler</div><div class="line">&#123;</div><div class="line">    public void uncaughtException(Thread t, Throwable e)</div><div class="line">    &#123;</div><div class="line">        System.out.println(&quot;This is:&quot; + t.getName() + &quot;,Message:&quot; + e.getMessage());</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在线程中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">        Thread.currentThread().setUncaughtExceptionHandler(ErrHandler);</div><div class="line">        //Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; &#123;</div><div class="line">        //    System.out.println(&quot;current thread is &quot; + t.getName() + &quot; &quot; + e.getMessage());</div><div class="line">        //&#125;);</div><div class="line">        Integer.parseInt(&quot;sfasf&quot;);</div><div class="line">        System.out.println(0);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>如果没有捕获异常，不会输出0，而有了handler则不影响下面的执行，会正常输出了。<br>或者是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread a = new Thread();</div><div class="line">a.setUncaughtExceptionHandler(ErrHandler);</div></pre></td></tr></table></figure></p>
<p>正如上面所写，在java 8中还可以用lamda表达式简化语法，用匿名handler代替。不过使用<code>a.setUEH(handler)</code>这种方式是策略模式的体现，更容易在需要的时候随时替换handler的实现，正如sort函数的Comparator参数一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，有个问题，如果Java子线程发生异常会怎么样？实际上会导致该线程直接终止。&lt;br&gt;当年自己写了个线程模型大概是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap 源码分析</title>
    <link href="http://hybnew.github.io/2017/03/01/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://hybnew.github.io/2017/03/01/HashMap-源码分析/</id>
    <published>2017-03-01T04:11:29.000Z</published>
    <updated>2017-03-01T04:11:29.901Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap 源码试解读</title>
    <link href="http://hybnew.github.io/2017/03/01/CocurrentHashMap-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB/"/>
    <id>http://hybnew.github.io/2017/03/01/CocurrentHashMap-源码试解读/</id>
    <published>2017-03-01T04:11:11.000Z</published>
    <updated>2017-03-01T04:11:11.231Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer (AQS) 源码试解读</title>
    <link href="http://hybnew.github.io/2017/03/01/AbstractQueuedSynchronizer-AQS-%E6%BA%90%E7%A0%81%E8%AF%95%E8%A7%A3%E8%AF%BB/"/>
    <id>http://hybnew.github.io/2017/03/01/AbstractQueuedSynchronizer-AQS-源码试解读/</id>
    <published>2017-03-01T04:10:51.000Z</published>
    <updated>2017-03-01T04:10:51.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Fork And Join框架计算Fibonacci数列</title>
    <link href="http://hybnew.github.io/2017/03/01/%E7%94%A8Fork-And-Join%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97Fibonacci%E6%95%B0%E5%88%97/"/>
    <id>http://hybnew.github.io/2017/03/01/用Fork-And-Join框架计算Fibonacci数列/</id>
    <published>2017-03-01T04:08:50.000Z</published>
    <updated>2017-03-01T09:03:05.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Fork And Join 的并发框架对与大型任务的分解计算是十分方便的。主要是将任务分割（fork）最后再合并（join）得到结果。<br>实际上使用了<code>分治</code>的思想。其中涉及到任务窃取算法等。</p>
</blockquote>
<p>以下是一个计算Fibonacci数列的Demo,使用BigInteger是为了避免溢出，但是计算效率大大降低，可以用Long类型代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package com.tw;</div><div class="line"></div><div class="line">import java.math.BigInteger;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.RecursiveTask;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Rick on 2017/2/27.</div><div class="line"> */</div><div class="line">public class ForkAndJoinTest extends RecursiveTask&lt;BigInteger&gt; &#123;</div><div class="line">    private int num;</div><div class="line">    private Map&lt;BigInteger, BigInteger&gt; intermediateResult;</div><div class="line"></div><div class="line">    public ForkAndJoinTest(int num, Map&lt;BigInteger, BigInteger&gt; map) &#123;</div><div class="line">        this.num = num;</div><div class="line">        intermediateResult = map;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected BigInteger compute() &#123;</div><div class="line">        if (num == 2)</div><div class="line">            return BigInteger.valueOf(1);</div><div class="line">        if (num == 1)</div><div class="line">            return BigInteger.valueOf(1);</div><div class="line">        if (num == 0)</div><div class="line">            return BigInteger.valueOf(0);</div><div class="line"></div><div class="line">        BigInteger lr, rr;</div><div class="line">        int i = num - 1;</div><div class="line">        int i1 = num - 2;</div><div class="line">        lr = getBigInteger(i);</div><div class="line">        rr = getBigInteger(i1);</div><div class="line"></div><div class="line">        return lr.add(rr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 使用map缓存计算结果</div><div class="line">    */</div><div class="line">    private BigInteger getBigInteger(int i) &#123;</div><div class="line">        BigInteger lr;</div><div class="line">        if (null != intermediateResult.get(i))</div><div class="line">            lr = intermediateResult.get(i);//cacha number</div><div class="line">        else &#123;</div><div class="line">            ForkAndJoinTest join1 = new ForkAndJoinTest(i, intermediateResult);</div><div class="line">            join1.fork();</div><div class="line">            lr = join1.join();</div><div class="line">            intermediateResult.put(BigInteger.valueOf(i), lr);</div><div class="line">        &#125;</div><div class="line">        return lr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ForkAndJoinTest() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">//        1,1,2,3,5,8,13,21</div><div class="line">        Map&lt;BigInteger, BigInteger&gt; map = new HashMap&lt;&gt;();</div><div class="line">        for (int i = 0; i &lt; 90; i++) &#123;</div><div class="line"></div><div class="line">            ForkAndJoinTest faj = new ForkAndJoinTest(i, map);</div><div class="line">            faj.fork();</div><div class="line">            BigInteger join = faj.join();</div><div class="line">            System.out.println(&quot;#&quot; + i + &quot; &quot; + join);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>举一反三，例如计算1+2+…+n就可以使用这种多线程模型，假设1+2比较耗时的话。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fork And Join 的并发框架对与大型任务的分解计算是十分方便的。主要是将任务分割（fork）最后再合并（join）得到结果。&lt;br&gt;实际上使用了&lt;code&gt;分治&lt;/code&gt;的思想。其中涉及到任务窃取算法等。&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Object的 wait &amp; notify &amp; notifyAll 方法探索</title>
    <link href="http://hybnew.github.io/2017/03/01/Java-Object%E7%9A%84-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/"/>
    <id>http://hybnew.github.io/2017/03/01/Java-Object的-wait-notify-notifyAll-方法探索/</id>
    <published>2017-03-01T03:25:33.000Z</published>
    <updated>2017-03-02T02:52:32.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  <figure class="highlight plain"><figcaption><span>的实例方法，所以可以用于各种引用类型。由于wait和notify/notifyAll必须在获取到monitor（锁）的区域内使用，所以，我们更多的是使用synchronized锁住线程共享的变量，并且在共享变量上做线程间通信。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[TOC]</div><div class="line"></div><div class="line">#### 关于wait和notify/notifyAll的使用</div><div class="line">举个栗子，关于消费者和生产者模型，会遇到队列（共享变量）为空即没有产品和队列已满的情况；如果是不使用ArrayBlockingQueue等阻塞队列，那么就需要自己对线程间的通信，或者称之为同步。说干就干，写个demo还是不费时间的。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.UUID;</p>
<p>/**</p>
<ul>
<li><p>Created by Rick on 2017/3/1.<br>*/<br>public class UncatchExceptionHandler {</p>
<p> private static volatile List<string> queue = new ArrayList&lt;&gt;(10);</string></p>
<p> public static void main(String[] args) {</p>
<pre><code>class R implements Runnable {
    @Override
    public void run() {
        for (; ; ) {

            synchronized (queue) {
                while (queue.size() == 0) {// must == 0
                    try {
                        //WAIT here util other thread notify
                        queue.wait();// same with wait(0)
</code></pre></li>
</ul>
<pre><code>                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName() + &quot;消费数据&quot; + queue.remove(queue.size() - 1) + &quot;,size=&quot; + queue.size());
                queue.notify();
                //queue.notifyAll();
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

Thread consumer1 = new Thread(new R());
Thread consumer2 = new Thread(new R());

Thread producer = new Thread(new Runnable() {
    @Override
    public void run() {

        for (; ; ) {

            synchronized (queue) {
                while (queue.size() == 10) {
                    try {
                        queue.wait(0);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                UUID rand = UUID.randomUUID();
                System.out.println(&quot;生产数据 :&quot; + rand.toString() + &quot;,size=&quot; + queue.size());

                queue.add(rand.toString());
                queue.notify();
</code></pre><p>//                        queue.notifyAll();<br>                        try {<br>                            Thread.sleep(1000);<br>                        } catch (InterruptedException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }<br>            }<br>        });</p>
<pre><code>    consumer1.start();
    consumer2.start();
    producer.start();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### javadoc reference</div><div class="line">&gt; &lt;pre&gt;Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.</div><div class="line">The current thread must own this object&apos;s monitor.</div><div class="line">This method causes the current thread (call it T) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</div><div class="line">Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened.</div><div class="line">Some other thread invokes the notifyAll method for this object.</div><div class="line">Some other thread interrupts thread T.</div><div class="line">The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</div><div class="line">The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.</div><div class="line">A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:</div><div class="line">           synchronized (obj) &#123;</div><div class="line">               while (&lt;condition does not hold&gt;)</div><div class="line">                   obj.wait(timeout);</div><div class="line">               ... // Perform action appropriate to condition</div><div class="line">           &#125;</div><div class="line">(For more information on this topic, see Section 3.2.3 in Doug Lea&apos;s &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley, 2000), or Item 50 in Joshua Bloch&apos;s &quot;Effective Java Programming Language Guide&quot; (Addison-Wesley, 2001).</div><div class="line">If the current thread is interrupted by any thread before or while it is waiting, then an InterruptedException is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</div><div class="line">Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.</div><div class="line">This method should only be called by a thread that is the owner of this object&apos;s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.&lt;/pre&gt;</div><div class="line"></div><div class="line">其中</div></pre></td></tr></table></figure></p>
<p>synchronized (obj) {<br>   while (<condition does="" not="" hold="">)<br>       obj.wait(timeout);<br>   … // Perform action appropriate to condition<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">这句话尤为重要。</div><div class="line"></div><div class="line">#### wait方法的loop纠结</div><div class="line"></div><div class="line">#### notify和notifyAll的区别</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 欢迎使用马克飞象</div><div class="line"></div><div class="line">@(示例笔记本)[马克飞象|帮助|Markdown]</div><div class="line"></div><div class="line">&gt;talk is cheap show me the code</div><div class="line">**mark**</div><div class="line"></div><div class="line"></div><div class="line">```sequence</div><div class="line"></div><div class="line">a-&gt;b:hello</div><div class="line">b-&gt;c:cd</div><div class="line">a-c: hello</div><div class="line">c--&gt;a: hello</div></pre></td></tr></table></figure></condition></p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="external">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<p>![hello] (<a href="http://img.kuaiji.com/2016/0823/1471936754786.jpg" target="_blank" rel="external">http://img.kuaiji.com/2016/0823/1471936754786.jpg</a>)</p>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">e=&gt;end</div><div class="line">op=&gt;operation: My Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li>[x] 已完成事项</li>
<li>[ ] 待办事项1</li>
<li>[ ] 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code></p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="external">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="external">@GGock</a></li>
<li>邮箱：<a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#104;&#117;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;">&#104;&#117;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="external">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="external">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;wait 和 notify/notifyAll 主要是用于线程间通信的方法，他们是Java  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;的实例方法，所以可以用于各种引用类型。由于wait和n
    
    </summary>
    
    
  </entry>
  
</feed>
